---
layout: post
title: "Android - Dependency Injection"
date: 2021-02-03 14:12:17 -400
lastmod: 2021-02-03 14:12:17 -400
sitemap:
  changefreq: daily
  priority: 1.0
categories: Android
background: "/img/classic_blue.jpeg"
---

의존성 주입(DI)는 많은 프로그래밍 분야에서 사용된다. 

## :thumbs_up: DI의 장점 3가지
1. 코드 재사용 가능
2. 리팩토링 편의성
3. 테스트 편의성

<br/>

## :construction_worker:️ 의존성 주입의 기본(How it works)
### :one: 의존성 주입이란?
클래스에서는 흔히 다른 클래스의 참조가 필요하다. 예를 들어서 `Car`클래스는 `Engine` 클래스의 참조가 필요할 수 있다.  
이처럼 필요한 클래스를 종속 항목(dependencies)라고 하고, 이 예에서는 `Car`클래스가 동작하기 위해서는 `Engine` 클래스의 인스턴스가 필요하므로, `Engine` 클래스가 종속 항목에 해당한다.  

### :two: 클래스가 필요한 객체를 얻는 방법은 3가지가 있다.
1. 클래스가 필요한 종속항목을 만든다.  
위의 예에서는 `Car`클래스에서 자체 `Engine` 인스턴스를 생성해서 초기화한다. 

2. 다른 곳에서 객체를 가지고 온다.  
Context의 `getter` 및 `getSystemService()`와 같은 일부 Android API는 이러한 방식으로 작동한다.  

3. 객체를 파라미터로 받아온다.  
앱은 객체가 필요한 클래스가 구성될 때 주입 항목들을 제공하거나, 각 종속 항목이 필요한 함수의 파라미터로 전달해줄 수 있다.  
위의 예시에서는 `Car`의 생성자에서 파라미터로 `Engine`인스턴스를 받도록 한다면 3번 경우에 해당한다.    
그리고 이 세번째 방식이 바로 **의존성 주입**에 해당한다.  
세번재 방식에 따르면, 클래스 인스턴스가 자체적으로 종속 항목을 갖는 것이 아닌, 클래스의 종속 항목들을 가지고 클래스에 전달해줄 수 있다.    

여기까지는 어렴풋이 이해가 갈 수도 있기에 예시와 함께 살펴보겠다.  

### :three: 클래스가 필요한 종속 항목을 직접 만드는 경우 예시 코드
1번 방식인 의존성 주입없이 `Car`클래스에서 자신만의 `Engine` 인스턴스를 생성하는 것은 다음과 같다.

{% highlight Kotlin %}
class Car {
    private val engine = Engine()
       
    fun start(){
        engine.start()
    }   
}

fun main(args: Any) {
    val car = Car()
    car.start()
}
{% endhighlight %}

이 예시는 의존성 주입의 사례가 아니다. 왜냐하면 `Car`클래스에서 자신이 필요한 `Engine` 인스턴스를 내부에서 자체적으로 생성하고 있기 때문이다. 
이렇게 했을 때의 문제점은 다음과 같다.

- `Car`클래스에서 자체적으로 `Engein`인스턴스를 생성하여 사용하는 경우 그림
![자체적으로 가지고 있는 경우 사진](https://developer.android.com/images/training/dependency-injection/1-car-engine-no-di.png)

### :four: 의존성 주입이 아닌 종속 항목이 필요한 클래스에서 자신만의 종속 항목 인스턴스를 생성할 때의 문제점
1. `Car`와 `Engine`이 밀접하게 연결되어 있다. 
즉, `Car`인스턴스는 한가지 유형의 `Engine`을 사용하게 되며`Engine`의 서브 클래스나 다른 대체 구현체를 쉽게 사용할 수 없다.  
다시 말해서 `Car`가 자체적인 `Engine`을 구성한다면, `Gas`나 `Electric` 타입의 엔진에 동일한 `Car`를 재사용하는 대신에, 두가지 유형의 `Car` 클래스를 만들어야 한다.  

2. `Engine`에 대한 강력한 의존성은 테스트를 어렵게 만든다.  
`Car`는 `Engine`의 실제 인스턴스를 사용하므로, 다양한 테스트 사례에서 테스트 더블을 사용하여 `Engine`을 수정할 수 없다.

### :five: 의존성 주입시 예시 코드
다음과 같이 `Car`각 인스턴스는 초기화시 자체적으로 `Engine` 객체를 생성하는 것이 아니라, `Engine`객체를 생성자의 파라미터로 받고 있다.

{% highlight Kotlin %}
class Car(private val engine: Engine) {
    fun start() {
        engine.start()
    }
}

fun main(args: Any) {
    val engine = Engine()
    val car = Car(engine)
    car.start()
}
{% end highlight%}

`main` 함수에서 `Car`를 사용한다. `Car`가 `Engine`에 의존성을 갖고 있기 때문에, app은 `Engine`인스턴스를 생성하여 이를 `Car`인스턴스를 생성하는데 사용한다.

- `Car`클래스에서 `Engine` 인스턴스를 의존성 주입받을 때 그림
![의존성 주입 받을 때 사진](https://developer.android.com/images/training/dependency-injection/1-car-engine-di.png)

### :six: 의존성 주입의 장점
1. `Car`가 재사용이 가능하다.  
`Engine`이 다양한 구현체를 사용하기위해서 매번 새로운 `Car`클래스를 생성하는 것이 아니라 `Car`에 전달할 수 있다.  
예를 들어서 `Car`에서 사용할 `ElectronicEngine`이라는 `Engine`의 서브 클래스를 만들 수 있다.  
DI를 사용한다면 `ElectronicEngine`을 `Car`에서 사용하려면, `ElectronicEngine` 인스턴스를 `Car`에 전달하기만 하면 되며, `Car`은 변경없이도 여전히 동작한다.  

2. `Car`를 테스팅하기 쉽다.  
테스트 더블을 전달하여 다양한 시나리오를 테스트할 수 있다.  
예를 들어 `FakeEngine`이라는 `Engine`의 테스트 더블을 구성하여 다양한 테스트에 맞게 구성할 수 있다.  

### :seven: 의존성 주입하는 방법 주요 2가지
1. 생성자 주입: 위의 예시 코드에서 사용한 방법이다. 즉, 클래스의 종속 항목을 생성자에 전달한다.

2. 필드 주입(setter 주입): 액티비티나 프레그먼트와 같은 특정 안드로이드 프레임워크 클래스들은 시스템이 인스턴스를 생성한다. 따라서 생성자 주입이 불가능하다.  
필드 주입을 사용하면 종속 항목은 클래스가 생성된 후 인스턴스화 된다.   
코드로는 다음과 같다.  

{% highlight Kotlin %}
class Car {
    lateinit var engine: Engine
    
    fun start() {
        engine.start()
    }
    
    fun main(args: Any) {
        val car = Car()
        car.engine = Engine()
        car.start()
    }
}
{% end highlight%}
 

> :bulb: 의존성 주입은 일반 코드가 특정 코드를 제어하는 제어의 역전(Inversion of Control) 원칙 을 기반으로 한다.


:eight: 자동 의존성 주입
이전 예시에서는 라이브러리를 사용하지 않고 종속 항목을 직접 생성, 주입, 관리했다.    
이렇게 하는 것을 **직접 의존성 주입** 혹은 **수동 의존성 주입**이라고 한다. 
  
`Car`에서는 종속 항목이 하나만 있었지만 종속 항목과 클래스가 많아지면 수동으로 종속 항목을 주입하는 것이 번거로워질 수 있다.  
또한 수동 의존성 주입에는 다음과 같은 **문제점**이 있다.
1. 규모가 큰 앱의 경우 모든 종속 항목을 가져와 올바르게 연결하는 것은 많은 양의 상용구 코드(boilerplate 코드)를 필요로 할 수 있다.  
다중 레이어 아키텍처에서는 최상위 계층의 객체를 생성하기 위해서 그 아래에 있는 계층의 모든 종속 항목을 제공해야 한다.  
예를 들어서 실제 자동차를 만들기 위해서 엔진, 변속기, 섀시 및 기타 부품이 필요할 수 있다. 그리고 엔진에는 실린더와 점화 플러그가 필요합니다.  

2. 종속 항목을 전달하기 전에 종속 항목을 구성할 수 없을 때 메모리에서 종속 항목들을 생명주기를 관리하는 커스텀 컨테이너(또는 의존성 그래프)를 만들고 유지해야 한다.  
예를 들어서 지연 초기화를 하거나 객체 범위를 앱의 플로우로 지정할 때에는 종속 항목을 전달하기 전에 종속 항목을 구성할 수 없다.

이 문제를 해결하기 위해서 종속 항목을 생성하고 제공하는 프로세스를 자동화하는 라이브러리들이 있다.  
그리고 이 라이브러리는 두가지 종류로 분류된다.  
1. 런타임시 종속 항목을 연결하는 리플렉션 기반 솔루션
2. 컴파일 타임에 종속 항목을 연결하는 코드를 작성하는 정적 솔루션

`Dagger`는 구글에서 유지 관리하며, Java, Kotlin 및 안드로이드 용으로 널리 사용되는 의존성 주입 라이브러리이다.  
`Dagger`는 의존성 주입 그래프를 자동으로 생성하고 관리하여 앱의 의존성 주입을 용이하게 한다.     
또한 `Guice`와 같은 리플렉션 기반 솔루션의 여러 개발 및 성능 문제를 해결하는 완전 정적이고 컴파일 타임 종속 항목을 제공한다. 

<br/>

## :avocado: 의존성 주입의 대안  
의존성 주입의 대안은 `서비스 로케이터`를 사용하는 것이다.  
`서비스 로케이터` 디자인 패턴은 구체적인 의존성에서 클래스 분리를 향상시킨다.  
`서비스 로케이터` 디자인 패턴을 구현하기 위해서는 종속 항목을 생성하고 저장한 후 필요에 따라 제공하는 `서비스 로케이터`라는 클래스를 생성하면 된다.  

{% highlight Kotlin %}
object ServiceLocator {
    fun getEngine(): Engine = Engine()
}

class Car {
    private val engine = ServiceLocator.getEngine()
    
    fun start() {
        engine.start()
    }
}

fun main(args: Any) {
    val car = Car()
    car.start()
}
{% end highlight %}

`서비스 로케이터`패턴은 요소가 삽입되는 방식에서 의존성 주입과 다르다.  
`서비스 로케이터` 패턴을 통해서 클래스는 주입받을 객체를 제어하고 요청한다.  
반면에 의존성 주입은 앱이 필요한 객체를 제어하고 사전에 주입해준다.  

### :right_point: 의존성 주입과 비교
1. 서비스 로케이터에서 필요한 종속 항목들은 코드를 테스트하기 어렵게 만든다.  
왜냐하면 모든 테스트가 동일한 전역 서비스 로케이터와 상호작용해야 하기 때문이다.  

2.  종속 항목은 API 영역이 아닌 클래스 구현 부분에서 인코딩된다.  
따라서 클래스 밖에서는 클래스가 필요한 것이 무엇인지 알기 어렵다.  
결과적으로 `Car` 또는 서비스 로케이터에서 사용가능한 종속 항목을 변경하면 참조 실패가 발생하여 런타임 오류 혹은 테스트 실패가 나타날 수 있다.  

3. 전체 앱의 생명주기가 아닌 다른 기간으로 범위를 지정하고 싶다면, 객체의 생명주기를 관리하는 것이 어렵다.  

<br/>

## :point_right: 안드로이드 앱에서 Hilt를 사용하는 것을 권장한다.  
`Hilt`는 Android에서 의존성 주입을 위한 Jetpack의 권장 라이브러리이다.  
`Hilt`는 모든 Android 클래스에 컨테이너를 제공하고 수명주기를 자동으로 관리함으로써 애플리케이션에서 DI를 실행하는 표준방법을 정의한다.  

`Hilt`는 Dagger가 제공하는 컴파일 타임 정확성, 런타임 퍼포먼스, 확장성 및 Android Studio 지원이라는 장점을 얻기 위해서 Dagger를 기반으로 빌드되었다.

<br/>

## :woman_judge: 결론
의존성 주입은 우리의 앱에 다음과 같은 장점을 제공한다.  
1. 클래스의 재사용성과 의존성 분리: 의존성(종속 항목) 구현체를 쉽게 변경할 수 있다.  
제어의 역전으로 인해서 코드의 재사용성이 향상되며 더이상 클래스들이 그들의 의존성(종속 항목)이 생성되는 방식을 제어하지 않는다. 대신에 모든 구성에서 작동한다.  

2. 리팩터링 편의성: 의존성(종속 항목)은 API 영역에서 테스트가능한 부분이 되기 때문에 구현 세부정보로서 숨겨지지 않고 객체 생성 시점이나 컴파일 타임에 테스트될 수 있다.

3. 테스트 편의성: 클래스는 더이상 자신의 의존성을 관리하지 않는다. 따라서 우리가 클래스를 테스트할 때 다양한 케이스를 테스트하기 위해서 다양한 의존성 구현을 클래스에 전달할 수 있다.


> 참고: [Dependency Injection in Android](https://developer.android.com/training/dependency-injection)