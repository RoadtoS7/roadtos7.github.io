---
title: "BACKJOON - 1931"
date: 2020-01-06 17:26:28 -0400
categories: algorythm python backjoon backjoon1931
---

오늘은 백준 1931번 문제인 회의실 배정 문제를 풀어보았습니다.
회의실 배정문제는 대표적인 **'그리디 알고리즘'** 문제입니다.

그리디 알고리즘이 무엇인지 간략하게 설명드리자면,
**미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 기법입니다.**
따라서 항상 최선의 답을 가져다 주지는 않습니다.

그리디 알고리즘을 사용하는 대표적인 문제로는 
- 활동 선택문제
- 분할 가능 배낭문제 
이렇게 두개의 문제가 있습니다.

먼저, 활동 선택 문제의 예시로는 각 수업마다 시작시간과 끝나는 시간이 잇을 때 하루에 가장 많은 수업을 할 수 있는 경우를 고르는 것입니다.
하루에 가장 많은 수업을 하기 위해서는 짧은 수업들을 여러개 선택하면 됩니다. 
즉, 각 단계에서 가장 빨리 끝나는 수업을 선택하면 됩니다.

이렇듯, 미래를 생각하지 않고 각 단계에서 최선인 짧은 수업을 선택하는 것이 바로 그리디 알고리즘을 사용하는 것입니다.

그리고 분할 가능 배낭문제의 예시로는 배낭에 담은 물건들의 가치 총합이 가장 최대가 되도록 물건을 담는 것입니다. 
단, 물건이 배낭에 담기에 너무 무거울 경우 물건을 나누어서 배낭에 담을 수 있는 경우입니다.
이럴 때는 각 단계에서 무게 대비 가치가 높은 것들을 먼저 넣는 것이 좋습니다.
따라서 이 경우도 그리디 알고리즘을 사용하는 문제에 해당합니다.


**회의실 문제**이 경우 활동 선택문제의 일종이라고 볼 수 있습니다.
각 회의가 겹치지 않으면서 회의실을 사용할 수 있는 최대 회의 개수를 찾는 것이기 때문에 각 단계에서 가장 빨리 끝나는
회의들을 찾으면 됩니다.

즉, 맨 처음에는 '가장 빨리 시작'하고 가장 빨리 끝나는 회의를 찾아야합니다.
그렇기 때문에 시작 시간을 기준으로 정렬합니다.

그다음에는 '가장 빨리 끝나는' 회의를 찾아야합니다.
따라서 앞에서 정렬한 결과를 끝나는 시간을 기준으로 정렬합니다.

그리고 가장 빨리 시작하고 가장 빨리 끝나는 회의를 제일 먼저 선택하고, 
선택한 회의의 끝나는 시간보다 끝나는 시간으로 큰 숫자를 갖는(늦게 끝나는) 회의를 정렬한 결과에서 찾습니다.
찾은 회의의 끝나는 시간을 기준으로 반복하여 끝나는 시간으로 큰 숫자를 갖는 회의를 찾으면
하루에 가장 많은 회의를 할 경우에 회의의 집합을 찾을 수 있습니다.

말로만 설명하면 어려우니 코드로 설명드리자면 다음과 같습니다.


​```
import sys

count = int(sys.stdin.readline()) #첫 줄에서 받은 회의의 개수를 반복 회수로서 저장해 둡니다.
meeting = [] # 회의 시간들을 담기 위한 배열을 만듭니다.
for i in range(count): # 회의 개수만큼 반복을 돌면서 회의의 시작시간과 회의의 끝시간의 배열을 담은 튜플을 회의시간 배열의 요소로서 저장합니다.
    start, end = map(int, sys.stdin.readline().split())
    meeting.append((start, end))

meeting= sorted(meeting, key = lambda time: time[0])
# 회의시간 배열을 회의가 시작하는 시간에 따라 정렬합니다. 그 결과로 빨리 시작하는 회의 순으로 정렬됩니다.
meeting = sorted(meeting, key = lambda time: time[1]) 
# 회의시간 배열을 회의가 끝나는 시간에 따라 정렬합니다. 그 결과로 빨리 시작하면서 빨리 끝나는 회의 순으로 정렬된 회의 시간의 집합을 얻을 수 있습니다.

fmt = list() # 하루에 최대로 하는 회의(시간)의 집합을 담을 빈 배열을 선언합니다.
fm = meeting[0][1] # 정렬결과에서 첫번째 배열요소에 해당하는 값을 비교 기준으로서 fm이라는 변수에 저장합니다.
fmt.append(meeting[0]) # 첫번째 배열요소에 해당하는 값을 첫번째 회의로서 저장합니다.

for i in range(1,count): # 반복을 돌면서 다음으로 빠르게 끝나는 회의를 찾아서 fmt회의 배열에 저장합니다.
    if fm <= meeting[i][0]: # 다음 회의에 해당하는 것은 현재 회의의 끝나는 시간보다 시작시간이 같거나 늦은 회의에 해당합니다.
        fmt.append(meeting[i]) # 이런 경우에만 fmt 회의 배열에 저장하고, 
        fm = meeting[i][1] # 다음 회의로서 저장한 회의가 끝나는 시간을 기준시간으로서 변수 fm에 저장합니다.
        
print(len(fmt)) # 반복이 끝나면 최종적으로 하루에 가장 많이 할 수 있는 회의의 집합을 얻을 수 있습니다.
# 이 회의의 개수를 출력하면 문제의 최종적인 답을 구할 수 있습니다.
​```
