I"y<h2 id="메모리-관리-기법">메모리 관리 기법</h2>
<p>여러개의 프로그램을 동시에 실행하기 위해서는 메모리에 여러 프로세스를 적재해야 한다.  <br />
이를 위해 메모리를 분할하여 관리하는 작업인 메모리 관리 기법이 등장했다.</p>

<p><br /></p>

<h2 id="메모리-관리-기법-종류-2가지">메모리 관리 기법 종류 2가지</h2>
<ol>
  <li>연속 할당 기법
    <ol>
      <li>하나의 프로세스를 메모리에 연속적으로 할당하는 기법</li>
      <li>ex) 고정 분할 방식, 가변 분할 방식</li>
    </ol>
  </li>
  <li>불연속 할당 기법
    <ol>
      <li>프로세스의 주소 공간을 나누어서 메모리에 불연속적으로 할당하는 기법</li>
      <li>ex) 페이징, 세그멘테이션</li>
    </ol>
  </li>
</ol>

<h2 id="연속-할당-기법">연속 할당 기법</h2>
<h3 id="고정-분할-방식">고정 분할 방식</h3>
<ol>
  <li>
    <p>물리 메모리를 고정된 크기의 파티션으로 나누고, 하나의 파티션당 하나의 프로세스를 할당한다.</p>
  </li>
  <li>장점
    <ul>
      <li>구현이 단순하다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>내부 단편화 발생 가능</li>
      <li>외부 단편화 발생 가능</li>
    </ul>
  </li>
</ol>

<h3 id="가변-분할-방식">가변 분할 방식</h3>
<ol>
  <li>
    <p>물리 메모리를 프로세스의 사이즈에 맞게 가변적으로 나누어 할당한다.</p>
  </li>
  <li>장점
    <ul>
      <li>내부 단편화가 발생하지 않는다.<br />
 왜냐하면 항상 프로세스의 사이즈에 맞게 메모리가 할당되기 때문이다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>외부 단편화가 발생 가능</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h2 id="불연속-할당-기법">불연속 할당 기법</h2>
<h3 id="페이지">페이지</h3>
<ol>
  <li>정의
    <ul>
      <li>프로세스의 주소 공간을 고정 크기의 페이지로 나누고, 
 메인 메모리도 페이지와 같은 크기의 프레임으로 나눈다.</li>
      <li>페이지단위로 메모리에 불연속적으로 할당한다.</li>
      <li>페이지 단위로 메모리에 올리거나, backing storage에 내려놓는다.</li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li>
        <p>외부 단편화가 발생하지 않는다.<br />
 메모리와 프로세스가 같은 사이즈로 나뉘기 때문이다.</p>
      </li>
      <li>
        <p>따라서 메모리 compaction 작업을 할 필요가 없다.</p>
      </li>
      <li>
        <p>dynamic storage allocation 문제가 사라진다.<br />
 💡 dynamic storage allocation = 가변 분할 방식에서 프로세스의 크기에 알맞는 가용 공간을 찾는 문제</p>
      </li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>
        <p>내부 단편화 발생할 수 있다.<br />
모든 프로세스의 사이즈가 페이지 크기의 배수가 아니다. <br />
따라서 마지막 페이지는 프레임 사이즈보다 작을 수 있다.<br />
해결법: 페이지 사이즈를 작게 만들면 된다.</p>
      </li>
      <li>
        <p>주소 변환이 복잡해진다.<br />
b) 프로세스가 메모리에 연속적으로 올라가는 것이 아니므로, 
페이지 단위로 메모리에 올라간 위치가 다르기 때문에,
주소 변환을 페이지단위로 해주어야 한다.</p>
      </li>
    </ul>
  </li>
</ol>

<h3 id="세그멘테이션">세그멘테이션</h3>
<ol>
  <li>정의
    <ul>
      <li>프로그램을 의미 단위인 세그먼트로 나누어, 세그먼트 단위로 메모리에 불연속적으로 적재하는 방식</li>
      <li>여기서 의미단위란 일반적으로 프로세스의 주소 공간에서 코드 영역, 데이터 영역, 스택 영역 의미
        <ul>
          <li>각각의 함수를 세그먼트로 만들어서 세그먼트 수를 증가시킬 수 있다.</li>
        </ul>
      </li>
      <li>세그 먼트 단위로 주소 변환을 해준다.</li>
    </ul>
  </li>
  <li>장점
    <ul>
      <li>내부 단편화가 없다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>dynamic storage allocation problem이 발생한다.<br />
b) 세그멘트는 의미단위이기 때문에, 각 세그먼트 사이즈는 서로 다르기 때문이다.</li>
      <li>외부 단편화 발생할 수 있다.<br />
 프로세스가 실행되면서 세그먼트가 메모리에 적재되고 해제되는 상황이 반복되며, 할당된 메모리 사이에 세그먼트보다 작아서 상요하지 못하는 메모리가 발생할 수 있다.</li>
    </ul>
  </li>
</ol>

<p><br />
<br /></p>
:ET