I"o<p>공식홈페이지에 나와있는 설명에 따르면,</p>
<blockquote>
  <p>OkHttp란 효율적인 HTTP 클라이언트이다.</p>
</blockquote>

<p>즉, OkHttp는 클라이언트 사이드에서 통신을 하기 위해서 사용된다.<br />
OkHttp를 사용하면 HTTP 통신을 쉽게 구현할 수 있다.</p>

<h3 id="point_right-그렇다면-왜-효율적인-클라이언트일까">:point_right: 그렇다면 왜 “효율적인” 클라이언트일까?</h3>
<ol>
  <li>HTTP/2의 지원 덕분에, 동일한 호스트에 보내는 요청이 동일한 소켓을 사용할 수 있도록 한다.
    <ul>
      <li>HTTP는 전송계층으로 TCP를 사용한다. TCP는 연결을 설정하고 데이터를 전달하는 역할을 한다.</li>
      <li>HTTP/1에서는 하나의 TCP연결에 대해서 하나의 요청 및 응답을 수행한다.</li>
      <li>HTTP/2에서는 모든 통신이 단일 TCP 연결을 통해서 수행되도록 하기 때문에, 동일한 소켓이 사용된다.</li>
    </ul>
  </li>
  <li>연결 풀링을 사용하면 요청 대기시간이 줄어든다.(HTTP/2를 사용할 수 없는 경우)
    <ul>
      <li>동일한 URL 로의 커넥션을 풀링하여, 다음번에 요청대 재활용할 수 있다.</li>
      <li>커넥션을 풀링하는 이유? 커넥션을 맺는 작업은 오버헤이드이기 때문이다.</li>
    </ul>
  </li>
  <li>GZIP이 다운로드 크기을 줄인다.
    <ul>
      <li>GZIP: 서버와 클라이언트간에 요청 및 응답을 주고받을 때, 속도를 향상시키기 위해서 리소스를 압축해준다.</li>
    </ul>
  </li>
  <li>응답 캐싱은 반복적인 요청에 대해서 네트워크를 보호한다.</li>
</ol>

<p>OkHttp는 네트워크 문제가 발생할 경우, 그 원인이 일반적인 연결 문제라면 자동으로 연결이 복구된다.<br />
만약 우리가 요청을 보낸 서비스가 다양한 IP 주소를 가지고 있다면, 첫번째 IP 주소로 연결이 실패할 경우, OkHttp는 두번째 IP 주소와 자동으로 연결을 시도한다.<br />
IPv4+IPv5 및 중복된 데이터 센터에서 호스팅되는 서비스대상으로는 이 기능이 필요하다.<br />
OkHttp는 모던 TLS(TLS 1.3, ALPN, certificate pinning) 기능들을 지원한다. 
(TLS는 TCP/IP 통신을 사용하는 경우에 적용될 수 있으며, 통신 계층에 보안을 제공하기 위해 설계된 암호 프로토콜이다. TLS는 SSL을 계승한 것으로 SSL보다 보안이 강화된 프로토콜이다. HTTPS에서 사용되는 암호화 프로토콜이 SSL/TLS이다. ) 
이 기능은 광범위한 연결을 위해서 사용되지 않도록 설정될 수 있다.</p>

<p>OkHttp를 사용하는 것은 쉽다.<br />
OkHttp의 요청, 응답 API는 유연한 여러가지 빌더와 불변성을 가지고 설계되었다.<br />
OkHttp는 동기식 블락킹 호출과 콜백을 가지는 비동기식 호출을 모두 지원한다.</p>

<p><del>조사를 하면서 알게 된건데 OkHttp 4.x 가 나온 것 같다…</del></p>

<p><br /></p>

<h3 id="fire-okhttp와-retrofit의-차이점">:fire: OkHttp와 Retrofit의 차이점</h3>
<ol>
  <li>
    <p>OkHttp
모든 로우 레벨의 네트워크 작업, 캐싱, 요청 및 응답을 다루는 HTTP 클라이언트(클라이언트 사이드 라이브러리)
즉, 커넥션 풀링, gzip, 캐싱, 네트워크 문제로부터 복구, 동기 및 비동기 호출, 리다이렉션, 재시도 등을 구현할 수 있다.</p>
  </li>
  <li>
    <p>Retrofit
OkHttp와 마찬가지로, HTTP 통신때 사용되는 클라이언트 사이드 라이브러리이지만 OkHttp를 기반으로 하여, 그 위에 존재하는 하이 레벨의 추상화 빌드이다.<br />
Retrofit과 OkHttp는 강하게 결합되어 있으며 Retrofit은 OkHttp와 함께 사용할 때, OkHttp를 더 잘 사용할 수 있도록 한다.<br />
즉, URL 조작, 요청, 로딩, 캐싱, 스레딩, 동기화, 동기 및 비동기 호출 등을 구현할 수 있다.<br />
OkHttp보다 하이레벨이기 때문에 네트워크 통신을 구현하기 더 쉽게 만들어 줬다.</p>
  </li>
</ol>

<h3 id="okhttp4-vs-okhttp3">OkHttp4 vs OkHttp3</h3>
<ul>
  <li>OkHttp4 부터는 라이브러리 사용 언어로 Kotlin이 사용할 수 있고, 나머지는 동일하다.<br />
(일부 OkHttp4에는 OkHttp3와 호환되지 않는 부분들이 존재하지만, 이 포스팅에서는 다루지 않겠다.)</li>
</ul>

:ET