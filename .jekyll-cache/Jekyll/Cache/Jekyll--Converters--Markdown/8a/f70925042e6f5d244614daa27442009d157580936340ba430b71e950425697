I"p<h2 id="52-스케쥴러-종류">5.2 스케쥴러 종류</h2>
<p>Rx의 장점은 특정 스케쥴러를 사용하다가 다른 스레드로 쉽게 바꿀 수 있다는 것 입니다.<br />
스케쥴러의 종류는 다음과 같습니다.</p>
<ol>
  <li>뉴 스레드 스케쥴러</li>
  <li>싱글 스레드 스케쥴러</li>
  <li>계산 스레드 스케쥴러</li>
  <li>IO 스레드 스케쥴러</li>
  <li>트램펄리 스레드 스케쥴러</li>
</ol>

<h3 id="521-뉴-스레드-스케쥴러">5.2.1 뉴 스레드 스케쥴러</h3>
<ul>
  <li>새로운 스레드를 생성합니다.</li>
  <li>새로운 스레드를 만들어서 동작을 실행시키고 싶으면, Scheduler.NewThread() 를 인자로 넣어주면 됩니다.(RxJava기준)</li>
  <li>그럼 뉴 스레드 스케쥴러는 요청을 받을 때마다 새로운 스레드를 생성합니다.</li>
  <li>결과적으로 새로운 스레드를 만들어서 동작을 실행시키는 것입니다.</li>
</ul>

<h3 id="522-계산-스케쥴러">5.2.2 계산 스케쥴러</h3>
<ul>
  <li>뉴 스레드 스케쥴러보다 더 활용도가 높습니다.</li>
  <li>CPU에 대응하는 계산용 스케쥴러입니다. 즉, 계산 작업을 할 때는 대기시간없이 결과를 빠르게 도출하는 것이 중요합니다. 계산 스케쥴러에서는 입출력작업을 하지 않기 때문에 대기시간이 그다지 길어지지 않습니다. 따라서 계산용으로 적합합니다.</li>
  <li>내부적으로 스레드 풀을 생성하며, 생성되는 스레드의 개수는 프로세스 개수와 동일합니다.</li>
  <li>RxJava 코드 = Schedulers.computation()</li>
</ul>

<h3 id="523-io-스케쥴러">5.2.3 IO 스케쥴러</h3>
<ul>
  <li>네트워크 통신과 같은 작업을 처리하는 스케쥴러입니다.</li>
  <li>계산 스케쥴러와 차이점(계산 스케쥴러와 비교해서 알아두면 좋습니다.):
    <ol>
      <li>기본으로 생성하는 스레드의 개수가 다릅니다.
        <ul>
          <li>계산 스케쥴러 = 프로세서 개수 만큼 생성 vs IO 스케쥴러 = 필요할 때마다 새로운 스레드를 생성</li>
          <li>이유: 입출력시간은 대기 시간이 길기 때문입니다. 따라서 스레드 개수가 한정될 경우, 작업 처리 시간이 매우 길어질 수 있습니다.</li>
        </ul>
      </li>
      <li>사용하는 용도에 차이가 납니다.
        <ul>
          <li>계산 스케쥴러 = 계산 작업 처리 vs IO 스케쥴러 = 파일 입출력 작업, 네트워크 상의 요청, DB 쿼리</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>입출력 작업의 코드는 일반적으로</li>
  <li>RxJava 코드 = Schdulers.io()</li>
</ul>

<h3 id="524-트램펄린-스케쥴러">5.2.4 트램펄린 스케쥴러</h3>
<ul>
  <li>스레드를 새로 생성하지 않고, 무한한 크기의 큐(Queue)를 생성해 놓는 스케쥴러입니다.</li>
  <li>다른 스케쥴러와의 차이점:
    <ol>
      <li>스레드를 새로 생성하지 않는다.</li>
      <li>기존의 스레드에 무한한 크기의 큐를 자동으로 생성한다.</li>
    </ol>
  </li>
  <li>트램펄린 스케쥴러의 스레드에서 처리할 작업은 큐에 저장해뒀다가 하나씩 꺼내서 처리하기 때문에, 첫번째 구독에 대한 작업이 다 처리된 후에야 두번째 구독에 대한 작업이 처리됩니다. (구독 간에 작업 순서가 엊갈리는 일은 없습니다.)</li>
  <li>RxJava 코드 = Schedulers.trampoline()</li>
</ul>

<h3 id="525-싱글-스레드-스케쥴러">5.2.5 싱글 스레드 스케쥴러</h3>
<ul>
  <li>별도로 스레드 하나를 생성하여, 구독(Subscription) 작업을 처리합니다.</li>
  <li>하나의 스레드만을 생성하며, 여러번의 구독작업이 있을 지라도 한개의 스레드를 반복하여 사용합니다.</li>
  <li>트램펄린 스케쥴러와 차이점: 트램펄린 스케쥴러는 스레드를 만들지 않고 main 스레드에 큐를 생성하여 기존 스레드(main 스레드)를 반복해서 사용하지만 싱글 스레드 스케쥴러는 스레드를 하나만 만들고 이 스레드를 계속해서 사용합니다.</li>
  <li>트랜펄린 스케쥴러와 공통점: 구독 순서에 따라서 작업이 차례대로 처리됩니다.</li>
  <li>여러개의 Observable에서 싱글 스케쥴러에서 실행하더라도, 모두 별도로 만들어진 하나의 스레드에서 실행됩니다.</li>
  <li>RxJava 코드 = Schedulers.single()</li>
</ul>

<h3 id="526-executor-변환-스케쥴러">5.2.6 Executor 변환 스케쥴러</h3>
<ul>
  <li>java.util.current 패키지에서 제공하는 실행자(Executor 클래스)를 Rx의 Scheduler로 변환시켜 줍니다.</li>
  <li>하지만 실행자와 Scheduler의 동작방식이 다르기 때문에 이 방법으로 Scheduler를 생성하는 것을 추천하지 않습니다.</li>
  <li>RxJava 코드 = Schedulers.from()</li>
</ul>

:ET